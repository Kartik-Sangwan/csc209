#include <stdio.h>
// Add your system includes here.
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include "ftree.h"


/*
 * Returns the FTree rooted at the path fname.
 *
 * Use the following if the file fname doesn't exist and return NULL:
 * fprintf(stderr, "The path (%s) does not point to an existing entry!\n", fname);
 *
 */
struct TreeNode *generate_ftree(const char *fname) {

    // Your implementation here.
    // Hint: consider implementing a recursive helper function that
    // takes fname and a path.  For the initial call on the 
    // helper function, the path would be "", since fname is the root
    // of the FTree.  For files at other depths, the path would be the
    // file path from the root to that file.
    if(stat(fname, &sb) == -1){
	fprintf(stderr, "The path (%s) does not point to an existing entry!\n", fname);
	return NULL;
    }
    char arr[256];
    arr[0] = '\0';
    struct TreeNode *tn = build_tree(fname, arr);
    printf("Mode: %lo", (unsigned long) sb.st_mode);
    printf("NAME: %s", fname);
    printf("File Size: %lld", (long long) sb.st_size);

    return NULL;
}

struct TreeNode *build_tree(const char *fname, char *path){

    struct stat sb;
    struct TreeNode tn = malloc(sizeof(struct TreeNode));
    strcpy(tn->fname, fname);
    stat(fname, &sb);
    if ((sb.st_mode & S_IFTM) == S_IFDIR) strcpy(tn.type, 'd');
    else if ((sb.st_mode & S_IFTM) == S_IFREG) strcpy(tn.type, '-');
    else if ((sb.st_mode & S_IFLNK) == S_IFLNK) strcpy(tn.type, 'l');
    tn->permissions = sb.st_mode;

    if ((tn.type == '-' || tn.type == 'l')){
        tn.next = NULL;
    	tn.contents = NULL;
    	return tn;
    } else if (tn.type == 'd'){
	//It is a directory.
	tn.next = NULL;
	DIR *dr_ptr = opendir(fname);
	if (dr_ptr == NULL){
	    perror("opendir");
	    return 1;
        }

	struct dirent *entry_ptr;
	entry_ptr = readdir(dr_ptr);
	char *new_path = malloc(strlen(path)+strlen(entry_ptr->dname+2));
	strcpy(new_path, path);
 	strcat(new_path, "/");
	strcat(new_path, entry_ptr->dname);
	strcat(new_path, "\0");
	tn.contents = build_tree(entry_ptr->dname, new_path);
	printf("Directory %s: contains", fname);
	while(entry_ptr != NULL){
	    printf("%s\n", entry_ptr->dname);
	    entry_ptr = readdir(entry_ptr);
	    struct TreeNode next_tn = malloc(sizeof(struct TreeNode));
	    struct TreeNode *curr_ptr = malloc(sizeof(struct *TreeNode));
	    curr_ptr = tn.contents;
 	    char *new_path = malloc(strlen(path)+strlen(entry_ptr->dname+2));
	    strcpy(new_path, path);
	    strcat(new_path, "/");
      	    strcat(new_path, entry_ptr->dname);
	    strcat(new_path, "\0");
	    curr_ptr.next = build_tree(entry_ptr->dname, new_path);
	    curr_ptr = curr_ptr.next;
	}
	return tn;
    }

/*
 * Prints the TreeNodes encountered on a preorder traversal of an FTree.
 *
 * The only print statements that you may use in this function are:
 * printf("===== %s (%c%o) =====\n", root->fname, root->type, root->permissions)
 * printf("%s (%c%o)\n", root->fname, root->type, root->permissions) 
*/
void print_ftree(struct TreeNode *root) {
    // Here's a trick for remembering what depth (in the tree) you're at
    // and printing 2 * that many spaces at the beginning of the line.
    static int depth = 0;
    //printf("%*s", depth * 2, "");

    // Your implementation here.
    //SHOULD USE A TEMPORARY VARIABLE HERE RATHER THAT ROOT MODIFICATION.

    while(root != NULL){
	printf("===== %s (%c%o) =====\n", root->fname, root->type, root->permissions);
	while(root->next != NULL){
	    if(root->contents != NULL){
		printf("%s", (++depth) * 2, "")
		print_ftree(root->contents);

	    }
	    root = root->next;
	    printf("%s", depth*2, "");;
	    printf("%s (%c%o)\n", root->fname, root->type, root->permissions);
	}
    }
}


/* 
 * Deallocate all dynamically-allocated memory in the FTree rooted at node.
 * 
 */
void deallocate_ftree (struct TreeNode *node) {
   
   // Your implementation here.

}
